"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const ts_log_debug_1 = require("ts-log-debug");
const ServerSettingsService_1 = require("../../config/services/ServerSettingsService");
const InjectionError_1 = require("../errors/InjectionError");
const InjectionScopeError_1 = require("../errors/InjectionScopeError");
const interfaces_1 = require("../interfaces");
const ProviderRegistry_1 = require("../registries/ProviderRegistry");
let globalInjector;
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/common";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 * injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 *
 * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.
 *
 */
class InjectorService extends Map {
    constructor() {
        super();
        globalInjector = this;
        this.initInjector();
        this.initSettings();
    }
    get settings() {
        return this.getProvider(ServerSettingsService_1.ServerSettingsService).instance;
    }
    /**
     *
     */
    initInjector() {
        this.forkProvider(InjectorService, this);
    }
    /**
     *
     */
    initSettings() {
        const provider = ProviderRegistry_1.GlobalProviders.get(ServerSettingsService_1.ServerSettingsService);
        this.forkProvider(ServerSettingsService_1.ServerSettingsService, this.invoke(provider.useClass));
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param target The class or symbol registered in InjectorService.
     * @returns {boolean}
     */
    get(target) {
        return (super.has(target) && super.get(core_1.getClassOrSymbol(target)).instance) || undefined;
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @param key
     * @returns {boolean}
     */
    has(key) {
        return super.has(core_1.getClassOrSymbol(key)) && !!this.get(key);
    }
    /**
     * The getProvider() method returns a specified element from a Map object.
     * @param key Required. The key of the element to return from the Map object.
     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
     */
    getProvider(key) {
        return super.get(core_1.getClassOrSymbol(key));
    }
    /**
     *
     * @param {RegistryKey} key
     * @param instance
     */
    forkProvider(key, instance) {
        const provider = ProviderRegistry_1.GlobalProviders.get(key).clone();
        this.set(key, provider);
        provider.instance = instance;
        return provider;
    }
    /**
     *
     * @param {ProviderType} type
     * @returns {[RegistryKey , Provider<any>][]}
     */
    getProviders(type) {
        return Array.from(this)
            .filter(([key, provider]) => (type ? provider.type === type : true))
            .map(([key, provider]) => provider);
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param target The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param designParamTypes Optional object. List of injectable types.
     * @param requiredScope
     * @returns {T} The class constructed.
     */
    invoke(target, locals = new Map(), designParamTypes, requiredScope = false) {
        const { onInvoke } = ProviderRegistry_1.GlobalProviders.getRegistrySettings(target);
        const provider = this.getProvider(target);
        const parentScope = core_1.Store.from(target).get("scope");
        if (!designParamTypes) {
            designParamTypes = core_1.Metadata.getParamTypes(target);
        }
        if (provider && onInvoke) {
            onInvoke(provider, locals, designParamTypes);
        }
        const services = designParamTypes.map(serviceType => this.mapServices({
            serviceType,
            target,
            locals,
            requiredScope,
            parentScope
        }));
        const instance = new target(...services);
        this.bindInjectableProperties(instance);
        return instance;
    }
    /**
     *
     * @returns {any}
     * @param options
     */
    mapServices(options) {
        const { serviceType, target, locals, parentScope, requiredScope } = options;
        const serviceName = typeof serviceType === "function" ? core_1.nameOf(serviceType) : serviceType;
        const localService = locals.get(serviceName) || locals.get(serviceType);
        if (localService) {
            return localService;
        }
        const provider = this.getProvider(serviceType);
        if (!provider) {
            throw new InjectionError_1.InjectionError(target, serviceName.toString());
        }
        const { buildable, injectable } = ProviderRegistry_1.GlobalProviders.getRegistrySettings(provider.type);
        const scopeReq = provider.scope === interfaces_1.ProviderScope.REQUEST;
        if (!injectable) {
            throw new InjectionError_1.InjectionError(target, serviceName.toString(), "not injectable");
        }
        if (!buildable || (provider.instance && !scopeReq)) {
            return provider.instance;
        }
        if (scopeReq && requiredScope && !parentScope) {
            throw new InjectionScopeError_1.InjectionScopeError(provider.useClass, target);
        }
        try {
            const instance = this.invoke(provider.useClass, locals, undefined, requiredScope);
            if (!scopeReq) {
                locals.set(provider.provide, instance);
            }
            return instance;
        }
        catch (er) {
            const error = new InjectionError_1.InjectionError(target, serviceName.toString(), "injection failed");
            error.origin = er;
            throw error;
        }
    }
    /**
     *
     * @param instance
     */
    bindInjectableProperties(instance) {
        const properties = core_1.Store.from(core_1.getClass(instance)).get("injectableProperties") || [];
        Object.keys(properties)
            .map(key => properties[key])
            .forEach(definition => {
            switch (definition.bindingType) {
                case "method":
                    this.bindMethod(instance, definition);
                    break;
                case "property":
                    this.bindProperty(instance, definition);
                    break;
                case "constant":
                    this.bindConstant(instance, definition);
                    break;
                case "value":
                    this.bindValue(instance, definition);
                    break;
                case "custom":
                    definition.onInvoke(this, instance, definition);
                    break;
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     */
    bindMethod(instance, { propertyKey }) {
        const target = core_1.getClass(instance);
        const originalMethod = instance[propertyKey];
        instance[propertyKey] = (locals = new Map()) => {
            return this.invokeMethod(originalMethod.bind(instance), {
                target,
                methodName: propertyKey,
                locals: locals instanceof Map ? locals : undefined
            });
        };
        instance[propertyKey].$injected = true;
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindProperty(instance, { propertyKey, useType }) {
        Object.defineProperty(instance, propertyKey, {
            get: () => {
                return this.get(useType);
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance, { propertyKey, expression, defaultValue }) {
        const descriptor = {
            get: () => this.settings.get(expression) || defaultValue,
            set: (value) => this.settings.set(expression, value),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance, { propertyKey, expression, defaultValue }) {
        const clone = (o) => {
            if (o) {
                return Object.freeze(JSON.parse(JSON.stringify(o)));
            }
            return defaultValue;
        };
        const descriptor = {
            get: () => clone(this.settings.get(expression)),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
        return descriptor;
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * class MyService {
     *      constructor(injectorService: InjectorService) {
     *          injectorService.invokeMethod(this.method, {
     *              this,
     *              methodName: 'method'
     *          });
     *      }
     *
     *   method(otherService: OtherService) {}
     * }
     * ```
     *
     * @returns {any}
     * @param handler The injectable method to invoke. Method parameters are injected according method signature.
     * @param options Object to configure the invocation.
     */
    invokeMethod(handler, options) {
        let { designParamTypes } = options;
        const { locals = new Map(), target, methodName } = options;
        if (handler.$injected) {
            return handler.call(target, locals);
        }
        if (!designParamTypes) {
            designParamTypes = core_1.Metadata.getParamTypes(core_1.prototypeOf(target), methodName);
        }
        const services = designParamTypes.map((serviceType) => this.mapServices({
            serviceType,
            target,
            locals,
            requiredScope: false,
            parentScope: false
        }));
        return handler(...services);
    }
    /**
     * Initialize injectorService and load all services/factories.
     */
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO copy all provider from GlobalProvider registry. In future this action will be performed from Bootstrap class
            ProviderRegistry_1.GlobalProviders.forEach((p, k) => {
                if (!this.has(k)) {
                    this.set(k, p.clone());
                }
            });
            this.build();
            return Promise.all([this.emit("$onInit")]);
        });
    }
    /**
     *
     * @returns {Map<Type<any>, any>}
     */
    build() {
        const locals = new Map();
        const config = this.get(ServerSettingsService_1.ServerSettingsService);
        this.forEach(provider => {
            const token = core_1.nameOf(provider.provide);
            const settings = ProviderRegistry_1.GlobalProviders.getRegistrySettings(provider.type);
            const useClass = core_1.nameOf(provider.useClass);
            if (settings.buildable) {
                const defaultScope = config.get(`${provider.type}Scope`) || interfaces_1.ProviderScope.SINGLETON;
                if (defaultScope && !provider.scope) {
                    provider.scope = defaultScope;
                }
                if (!locals.has(provider.provide)) {
                    provider.instance = this.invoke(provider.useClass, locals);
                    ts_log_debug_1.$log.debug(core_1.nameOf(provider.provide), "built", token === useClass ? "" : `from class ${useClass}`);
                }
            }
            else {
                provider.scope = interfaces_1.ProviderScope.SINGLETON;
                ts_log_debug_1.$log.debug(core_1.nameOf(provider.provide), "loaded");
            }
            if (provider.instance) {
                locals.set(provider.provide, provider.instance);
            }
        });
        return locals;
    }
    /**
     * Emit an event to all service. See service [lifecycle hooks](docs/services/lifecycle-hooks.md).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each services.
     * @returns {Promise<any[]>} A list of promises.
     */
    emit(eventName, ...args) {
        const promises = [];
        ts_log_debug_1.$log.debug("\x1B[1mCall hook", eventName, "\x1B[22m");
        this.forEach(provider => {
            const service = provider.instance;
            if (service && eventName in service) {
                /* istanbul ignore next */
                if (eventName === "$onInjectorReady") {
                    ts_log_debug_1.$log.warn("$onInjectorReady hook is deprecated, use $onInit hook insteadof. See https://goo.gl/KhvkVy");
                }
                const promise = service[eventName](...args);
                /* istanbul ignore next */
                if (promise && promise.then) {
                    promises.push(core_1.promiseTimeout(promise, 1000).then(result => InjectorService.checkPromiseStatus(eventName, result, core_1.nameOf(provider.useClass))));
                }
            }
        });
        /* istanbul ignore next */
        if (promises.length) {
            ts_log_debug_1.$log.debug("\x1B[1mCall hook", eventName, " promises built\x1B[22m");
            return core_1.promiseTimeout(Promise.all(promises), 2000).then(result => InjectorService.checkPromiseStatus(eventName, result));
        }
        return Promise.resolve();
    }
    /**
     *
     * @param {string} eventName
     * @param result
     * @param {string} service
     */
    /* istanbul ignore next */
    static checkPromiseStatus(eventName, result, service) {
        if (!result.ok) {
            const msg = `Timeout on ${eventName} hook. Promise are unfulfilled ${service ? "on service" + service : ""}`;
            if (process.env.NODE_ENV === core_1.Env.PROD) {
                throw msg;
            }
            else {
                setTimeout(() => ts_log_debug_1.$log.warn(msg, "In production, the warning will down the server!"), 1000);
            }
        }
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param target The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param designParamTypes Optional object. List of injectable types.
     * @param requiredScope
     * @returns {T} The class constructed.
     */
    /* istanbul ignore next */
    static invoke(target, locals = new Map(), designParamTypes, requiredScope = false) {
        return globalInjector.invoke(target, locals, designParamTypes, requiredScope);
    }
    /**
     * Construct the service with his dependencies.
     * @param target The service to be built.
     * @deprecated
     */
    /* istanbul ignore next */
    static construct(target) {
        const provider = ProviderRegistry_1.ProviderRegistry.get(target);
        return this.invoke(provider.useClass);
    }
    /**
     * Emit an event to all service. See service [lifecycle hooks](docs/services/lifecycle-hooks.md).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each services.
     * @returns {Promise<any[]>} A list of promises.
     */
    /* istanbul ignore next */
    static emit(eventName, ...args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return globalInjector.emit(eventName, args);
        });
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param target The class or symbol registered in InjectorService.
     * @returns {boolean}
     */
    /* istanbul ignore next */
    static get(target) {
        return globalInjector.get(target).instance;
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * class MyService {
     *      constructor(injectorService: InjectorService) {
     *          injectorService.invokeMethod(this.method.bind(this), {
     *              target: this,
     *              methodName: 'method'
     *          });
     *      }
     *
     *   method(otherService: OtherService) {}
     * }
     * ```
     *
     * @returns {any}
     * @param handler The injectable method to invoke. Method parameters are injected according method signature.
     * @param options Object to configure the invocation.
     */
    /* istanbul ignore next */
    static invokeMethod(handler, options) {
        return globalInjector.invokeMethod(handler, options);
    }
    /**
     * Set a new provider from providerSetting.
     * @param provider provide token.
     * @param instance Instance
     * @deprecated Use registerProvider or registerService or registerFactory instead of
     */
    /* istanbul ignore next */
    static set(provider, instance) {
        if (!provider.provide) {
            provider = {
                provide: provider,
                type: "factory",
                useClass: provider,
                instance: instance || provider
            };
        }
        ProviderRegistry_1.registerProvider(provider);
        return InjectorService;
    }
    /**
     * Check if the service of factory exists in `InjectorService`.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     * import MyService from "./services";
     *
     * class OtherService {
     *    constructor(injectorService: InjectorService) {
     *        const exists = injectorService.has(MyService); // true or false
     *    }
     * }
     * ```
     *
     * @param target The service class
     * @returns {boolean}
     */
    /* istanbul ignore next */
    static has(target) {
        return globalInjector.has(target);
    }
    /**
     * Initialize injectorService and load all services/factories.
     */
    /* istanbul ignore next */
    static load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!globalInjector) {
                globalInjector = new InjectorService();
            }
            return globalInjector.load();
        });
    }
    /**
     * Add a new service in the registry. This service will be constructed when `InjectorService`will loaded.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * export default class MyFooService {
     *     constructor(){}
     *     getFoo() {
     *         return "test";
     *     }
     * }
     *
     * InjectorService.service(MyFooService);
     * const injector = new InjectorService();
     * injector.load();
     *
     * const myFooService = injector.get<MyFooService>(MyFooService);
     * myFooService.getFoo(); // test
     * ```
     *
     * @param target The class to add in registry.
     * @deprecated Use registerService or registerFactory instead of.
     */
    /* istanbul ignore next */
    static service(target) {
        return ProviderRegistry_1.registerService(target);
    }
    /**
     * Add a new factory in `InjectorService` registry.
     *
     * #### Example with symbol definition
     *
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * export interface IMyFooFactory {
     *    getFoo(): string;
     * }
     *
     * export type MyFooFactory = IMyFooFactory;
     * export const MyFooFactory = Symbol("MyFooFactory");
     *
     * InjectorService.factory(MyFooFactory, {
     *      getFoo:  () => "test"
     * });
     *
     * @Service()
     * export class OtherService {
     *      constructor(@Inject(MyFooFactory) myFooFactory: MyFooFactory){
     *          console.log(myFooFactory.getFoo()); /// "test"
     *      }
     * }
     * ```
     *
     * > Note: When you use the factory method with Symbol definition, you must use the `@Inject()`
     * decorator to retrieve your factory in another Service. Advice: By convention all factory class name will be prefixed by
     * `Factory`.
     *
     * #### Example with class
     *
     * ```typescript
     * import {InjectorService} from "@tsed/common";
     *
     * export class MyFooService {
     *  constructor(){}
     *      getFoo() {
     *          return "test";
     *      }
     * }
     *
     * InjectorService.factory(MyFooService, new MyFooService());
     *
     * @Service()
     * export class OtherService {
     *      constructor(myFooService: MyFooService){
     *          console.log(myFooFactory.getFoo()); /// "test"
     *      }
     * }
     * ```
     * @deprecated Use registerFactory instead of
     */
    /* istanbul ignore next */
    static factory(target, instance) {
        return ProviderRegistry_1.registerFactory(target, instance);
    }
}
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Map, Array, Boolean]),
    tslib_1.__metadata("design:returntype", Object)
], InjectorService, "invoke", null);
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Object)
], InjectorService, "construct", null);
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], InjectorService, "emit", null);
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Object)
], InjectorService, "get", null);
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
], InjectorService, "invokeMethod", null);
tslib_1.__decorate([
    core_1.Deprecated("Use registerService(), registerFactory() or registerProvider() util instead of")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
], InjectorService, "set", null);
tslib_1.__decorate([
    core_1.Deprecated("static InjectorService.has(). Removed feature.")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Boolean)
], InjectorService, "has", null);
tslib_1.__decorate([
    core_1.Deprecated("removed feature")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], InjectorService, "load", null);
tslib_1.__decorate([
    core_1.Deprecated("Use registerService() util instead of")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], InjectorService, "service", null);
tslib_1.__decorate([
    core_1.Deprecated("Use registerFactory() util instead of")
    /* istanbul ignore next */
    ,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
], InjectorService, "factory", null);
exports.InjectorService = InjectorService;
/**
 * Create the first service InjectorService
 */
ProviderRegistry_1.registerFactory(InjectorService);

//# sourceMappingURL=InjectorService.js.map
