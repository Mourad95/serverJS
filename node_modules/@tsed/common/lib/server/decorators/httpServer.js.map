{"version":3,"sources":["../src/common/server/decorators/httpServer.ts"],"names":[],"mappings":";;AAAA,2EAAqE;AAGrE,uDAAkD;AAclD;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,oBAA2B,MAAiB,EAAE,SAAiB,EAAE,UAAsD;IACrH,OAAO,eAAM,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;AAC3D,CAAC;AAFD,gCAEC;AAED,kCAAe,CAAC,UAAU,CAAC,CAAC","file":"httpServer.js","sourcesContent":["import {registerFactory} from \"../../di/registries/ProviderRegistry\";\nimport {Type} from \"@tsed/core\";\nimport * as Http from \"http\";\nimport {Inject} from \"../../di/decorators/inject\";\n\nexport interface IHttpFactory {\n  (target: Type<any>, targetKey: string, descriptor: TypedPropertyDescriptor<Function> | number): any;\n\n  /**\n   * @deprecated\n   * @returns {\"https\".Server}\n   */\n  get(): Http.Server;\n}\n\nexport type HttpServer = Http.Server & IHttpFactory;\n\n/**\n * Inject the Http.Server instance.\n *\n * ### Example\n *\n * ```typescript\n * import {HttpServer, Service} from \"@tsed/common\";\n *\n * @Service()\n * export default class OtherService {\n *    constructor(@HttpServer httpServer: HttpServer) {}\n * }\n * ```\n *\n * > Note: TypeScript transform and store `HttpServer` as `Function` type in the metadata. So to inject a factory, you must use the `@Inject(type)` decorator.\n *\n * @param {Type<any>} target\n * @param {string} targetKey\n * @param {TypedPropertyDescriptor<Function> | number} descriptor\n * @returns {any}\n * @decorator\n */\nexport function HttpServer(target: Type<any>, targetKey: string, descriptor: TypedPropertyDescriptor<Function> | number) {\n  return Inject(HttpServer)(target, targetKey, descriptor);\n}\n\nregisterFactory(HttpServer);\n"],"sourceRoot":"../../../"}