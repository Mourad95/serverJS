{"version":3,"sources":["../src/common/di/services/InjectorService.ts"],"names":[],"mappings":";;;AAAA,qCAYoB;AACpB,+CAAkC;AAClC,uFAAkF;AAElF,6DAAwD;AACxD,uEAAkE;AAClE,8CAA0E;AAG1E,qEAAqI;AAErI,IAAI,cAAmB,CAAC;AAExB;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,qBAA6B,SAAQ,GAA+B;IAClE;QACE,KAAK,EAAE,CAAC;QACR,cAAc,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,WAAW,CAAC,6CAAqB,CAAE,CAAC,QAAQ,CAAC;IAC3D,CAAC;IAED;;OAEG;IACK,YAAY;QAClB,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;IAC3C,CAAC;IAED;;OAEG;IACK,YAAY;QAClB,MAAM,QAAQ,GAAG,kCAAe,CAAC,GAAG,CAAC,6CAAqB,CAAE,CAAC;QAE7D,IAAI,CAAC,YAAY,CAAC,6CAAqB,EAAE,IAAI,CAAC,MAAM,CAAwB,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;IAClG,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACH,GAAG,CAAI,MAA8B;QACnC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,uBAAgB,CAAC,MAAM,CAAC,CAAE,CAAC,QAAQ,CAAC,IAAI,SAAS,CAAC;IAC3F,CAAC;IAED;;;;OAIG;IACH,GAAG,CAAC,GAAgB;QAClB,OAAO,KAAK,CAAC,GAAG,CAAC,uBAAgB,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7D,CAAC;IAED;;;;OAIG;IACH,WAAW,CAAC,GAAgB;QAC1B,OAAO,KAAK,CAAC,GAAG,CAAC,uBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACH,YAAY,CAAC,GAAgB,EAAE,QAAc;QAC3C,MAAM,QAAQ,GAAG,kCAAe,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,KAAK,EAAE,CAAC;QACnD,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QAExB,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAE7B,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;;;OAIG;IACH,YAAY,CAAC,IAA4B;QACvC,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;aACpB,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aACnE,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,MAAM,CAAI,MAAW,EAAE,SAAsC,IAAI,GAAG,EAAE,EAAE,gBAAwB,EAAE,gBAAyB,KAAK;QAC9H,MAAM,EAAC,QAAQ,EAAC,GAAG,kCAAe,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;QAC/D,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAC1C,MAAM,WAAW,GAAG,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAEpD,IAAI,CAAC,gBAAgB,EAAE;YACrB,gBAAgB,GAAG,eAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;SACnD;QAED,IAAI,QAAQ,IAAI,QAAQ,EAAE;YACxB,QAAQ,CAAC,QAAQ,EAAE,MAAM,EAAE,gBAAgB,CAAC,CAAC;SAC9C;QAED,MAAM,QAAQ,GAAG,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAClD,IAAI,CAAC,WAAW,CAAC;YACf,WAAW;YACX,MAAM;YACN,MAAM;YACN,aAAa;YACb,WAAW;SACZ,CAAC,CACH,CAAC;QAEF,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC;QAEzC,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC;QAExC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;;;OAIG;IACK,WAAW,CAAC,OAAY;QAC9B,MAAM,EAAC,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,aAAa,EAAC,GAAG,OAAO,CAAC;QAC1E,MAAM,WAAW,GAAG,OAAO,WAAW,KAAK,UAAU,CAAC,CAAC,CAAC,aAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;QAC1F,MAAM,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAExE,IAAI,YAAY,EAAE;YAChB,OAAO,YAAY,CAAC;SACrB;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAE/C,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,+BAAc,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,EAAE,CAAC,CAAC;SAC1D;QAED,MAAM,EAAC,SAAS,EAAE,UAAU,EAAC,GAAG,kCAAe,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnF,MAAM,QAAQ,GAAG,QAAQ,CAAC,KAAK,KAAK,0BAAa,CAAC,OAAO,CAAC;QAE1D,IAAI,CAAC,UAAU,EAAE;YACf,MAAM,IAAI,+BAAc,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,EAAE,EAAE,gBAAgB,CAAC,CAAC;SAC5E;QAED,IAAI,CAAC,SAAS,IAAI,CAAC,QAAQ,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE;YAClD,OAAO,QAAQ,CAAC,QAAQ,CAAC;SAC1B;QAED,IAAI,QAAQ,IAAI,aAAa,IAAI,CAAC,WAAW,EAAE;YAC7C,MAAM,IAAI,yCAAmB,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SAC1D;QAED,IAAI;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAM,QAAQ,CAAC,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;YAEvF,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;aACxC;YAED,OAAO,QAAQ,CAAC;SACjB;QAAC,OAAO,EAAE,EAAE;YACX,MAAM,KAAK,GAAG,IAAI,+BAAc,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,EAAE,EAAE,kBAAkB,CAAC,CAAC;YACpF,KAAa,CAAC,MAAM,GAAG,EAAE,CAAC;YAC3B,MAAM,KAAK,CAAC;SACb;IACH,CAAC;IAED;;;OAGG;IACK,wBAAwB,CAAC,QAAa;QAC5C,MAAM,UAAU,GAA0B,YAAK,CAAC,IAAI,CAAC,eAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC;QAE3G,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;aACpB,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;aAC3B,OAAO,CAAC,UAAU,CAAC,EAAE;YACpB,QAAQ,UAAU,CAAC,WAAW,EAAE;gBAC9B,KAAK,QAAQ;oBACX,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACtC,MAAM;gBACR,KAAK,UAAU;oBACb,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACxC,MAAM;gBACR,KAAK,UAAU;oBACb,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACxC,MAAM;gBACR,KAAK,OAAO;oBACV,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACrC,MAAM;gBACR,KAAK,QAAQ;oBACX,UAAU,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;oBAChD,MAAM;aACT;QACH,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IACK,UAAU,CAAC,QAAa,EAAE,EAAC,WAAW,EAA6B;QACzE,MAAM,MAAM,GAAG,eAAQ,CAAC,QAAQ,CAAC,CAAC;QAClC,MAAM,cAAc,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC;QAE7C,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,SAAsC,IAAI,GAAG,EAAoB,EAAE,EAAE;YAC5F,OAAO,IAAI,CAAC,YAAY,CAAC,cAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACvD,MAAM;gBACN,UAAU,EAAE,WAAW;gBACvB,MAAM,EAAE,MAAM,YAAY,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;aACnD,CAAC,CAAC;QACL,CAAC,CAAC;QAEF,QAAQ,CAAC,WAAW,CAAC,CAAC,SAAS,GAAG,IAAI,CAAC;IACzC,CAAC;IAED;;;;;OAKG;IACK,YAAY,CAAC,QAAa,EAAE,EAAC,WAAW,EAAE,OAAO,EAA6B;QACpF,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,EAAE;YAC3C,GAAG,EAAE,GAAG,EAAE;gBACR,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAC3B,CAAC;SACF,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACK,SAAS,CAAC,QAAa,EAAE,EAAC,WAAW,EAAE,UAAU,EAAE,YAAY,EAA2B;QAChG,MAAM,UAAU,GAAG;YACjB,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,YAAY;YACxD,GAAG,EAAE,CAAC,KAAU,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC;YACzD,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;SACnB,CAAC;QACF,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAC3D,CAAC;IAED;;;;;OAKG;IACK,YAAY,CAAC,QAAa,EAAE,EAAC,WAAW,EAAE,UAAU,EAAE,YAAY,EAA2B;QACnG,MAAM,KAAK,GAAG,CAAC,CAAM,EAAE,EAAE;YACvB,IAAI,CAAC,EAAE;gBACL,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACrD;YAED,OAAO,YAAY,CAAC;QACtB,CAAC,CAAC;QAEF,MAAM,UAAU,GAAG;YACjB,GAAG,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAE/C,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;SACnB,CAAC;QACF,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;QAEzD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BG;IACI,YAAY,CAAC,OAAY,EAAE,OAA+B;QAC/D,IAAI,EAAC,gBAAgB,EAAC,GAAG,OAAO,CAAC;QACjC,MAAM,EAAC,MAAM,GAAG,IAAI,GAAG,EAAY,EAAE,MAAM,EAAE,UAAU,EAAC,GAAG,OAAO,CAAC;QAEnE,IAAI,OAAO,CAAC,SAAS,EAAE;YACrB,OAAO,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;SACrC;QAED,IAAI,CAAC,gBAAgB,EAAE;YACrB,gBAAgB,GAAG,eAAQ,CAAC,aAAa,CAAC,kBAAW,CAAC,MAAM,CAAC,EAAE,UAAU,CAAC,CAAC;SAC5E;QAED,MAAM,QAAQ,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC,WAAgB,EAAE,EAAE,CACzD,IAAI,CAAC,WAAW,CAAC;YACf,WAAW;YACX,MAAM;YACN,MAAM;YACN,aAAa,EAAE,KAAK;YACpB,WAAW,EAAE,KAAK;SACnB,CAAC,CACH,CAAC;QAEF,OAAO,OAAO,CAAC,GAAG,QAAQ,CAAC,CAAC;IAC9B,CAAC;IAED;;OAEG;IACG,IAAI;;YACR,oHAAoH;YACpH,kCAAe,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC/B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;oBAChB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;iBACxB;YACH,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,KAAK,EAAE,CAAC;YAEb,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAC7C,CAAC;KAAA;IAED;;;OAGG;IACK,KAAK;QACX,MAAM,MAAM,GAAwB,IAAI,GAAG,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAwB,6CAAqB,CAAE,CAAC;QAEvE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;YACtB,MAAM,KAAK,GAAG,aAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YACvC,MAAM,QAAQ,GAAG,kCAAe,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YACpE,MAAM,QAAQ,GAAG,aAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAE3C,IAAI,QAAQ,CAAC,SAAS,EAAE;gBACtB,MAAM,YAAY,GAAkB,MAAM,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,IAAI,OAAO,CAAC,IAAI,0BAAa,CAAC,SAAS,CAAC;gBAEnG,IAAI,YAAY,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;oBACnC,QAAQ,CAAC,KAAK,GAAG,YAAY,CAAC;iBAC/B;gBAED,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;oBACjC,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;oBAC3D,mBAAI,CAAC,KAAK,CAAC,aAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,QAAQ,EAAE,CAAC,CAAC;iBACnG;aACF;iBAAM;gBACL,QAAQ,CAAC,KAAK,GAAG,0BAAa,CAAC,SAAS,CAAC;gBACzC,mBAAI,CAAC,KAAK,CAAC,aAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,CAAC;aAChD;YAED,IAAI,QAAQ,CAAC,QAAQ,EAAE;gBACrB,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;aACjD;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACI,IAAI,CAAC,SAAiB,EAAE,GAAG,IAAW;QAC3C,MAAM,QAAQ,GAAmB,EAAE,CAAC;QAEpC,mBAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;QAEtD,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;YACtB,MAAM,OAAO,GAAG,QAAQ,CAAC,QAAQ,CAAC;YAElC,IAAI,OAAO,IAAI,SAAS,IAAI,OAAO,EAAE;gBACnC,0BAA0B;gBAC1B,IAAI,SAAS,KAAK,kBAAkB,EAAE;oBACpC,mBAAI,CAAC,IAAI,CAAC,4FAA4F,CAAC,CAAC;iBACzG;gBAED,MAAM,OAAO,GAAQ,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;gBAEjD,0BAA0B;gBAC1B,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE;oBAC3B,QAAQ,CAAC,IAAI,CACX,qBAAc,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAC,kBAAkB,CAAC,SAAS,EAAE,MAAM,EAAE,aAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAC/H,CAAC;iBACH;aACF;QACH,CAAC,CAAC,CAAC;QAEH,0BAA0B;QAC1B,IAAI,QAAQ,CAAC,MAAM,EAAE;YACnB,mBAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,SAAS,EAAE,yBAAyB,CAAC,CAAC;YAErE,OAAO,qBAAc,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAC,kBAAkB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;SAC1H;QAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IAEH,0BAA0B;IAClB,MAAM,CAAC,kBAAkB,CAAC,SAAiB,EAAE,MAAW,EAAE,OAAgB;QAChF,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;YACd,MAAM,GAAG,GAAG,cAAc,SAAS,kCAAkC,OAAO,CAAC,CAAC,CAAC,YAAY,GAAG,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC7G,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,UAAG,CAAC,IAAI,EAAE;gBACrC,MAAM,GAAG,CAAC;aACX;iBAAM;gBACL,UAAU,CAAC,GAAG,EAAE,CAAC,mBAAI,CAAC,IAAI,CAAC,GAAG,EAAE,kDAAkD,CAAC,EAAE,IAAI,CAAC,CAAC;aAC5F;SACF;IACH,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;OAqBG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,MAAM,CACX,MAAW,EACX,SAAsC,IAAI,GAAG,EAAiB,EAC9D,gBAAwB,EACxB,gBAAyB,KAAK;QAE9B,OAAO,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,gBAAgB,EAAE,aAAa,CAAC,CAAC;IAChF,CAAC;IAED;;;;OAIG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,SAAS,CAAI,MAA0B;QAC5C,MAAM,QAAQ,GAAkB,mCAAgB,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC;QAE9D,OAAO,IAAI,CAAC,MAAM,CAAM,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAED;;;;;OAKG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAO,IAAI,CAAC,SAAiB,EAAE,GAAG,IAAW;;YACjD,OAAO,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAC9C,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;OAkBG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,GAAG,CAAI,MAAmB;QAC/B,OAAO,cAAc,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,QAAQ,CAAC;IAC9C,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,YAAY,CAAC,OAAY,EAAE,OAAuC;QACvE,OAAO,cAAc,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAED;;;;;OAKG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,GAAG,CAAC,QAA8B,EAAE,QAAc;QACvD,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;YACrB,QAAQ,GAAG;gBACT,OAAO,EAAE,QAAQ;gBACjB,IAAI,EAAE,SAAS;gBACf,QAAQ,EAAE,QAAQ;gBAClB,QAAQ,EAAE,QAAQ,IAAI,QAAQ;aAC/B,CAAC;SACH;QAED,mCAAgB,CAAC,QAAQ,CAAC,CAAC;QAE3B,OAAO,eAAe,CAAC;IACzB,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,GAAG,CAAC,MAAW;QACpB,OAAO,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAED;;OAEG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAO,IAAI;;YACf,IAAI,CAAC,cAAc,EAAE;gBACnB,cAAc,GAAG,IAAI,eAAe,EAAE,CAAC;aACxC;YAED,OAAO,cAAc,CAAC,IAAI,EAAE,CAAC;QAC/B,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,OAAO,CAAC,MAAW;QACxB,OAAO,kCAAe,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAsDG;IAEH,AACA,0BAD0B;IAC1B,MAAM,CAAC,OAAO,CAAC,MAAW,EAAE,QAAa;QACvC,OAAO,kCAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAC3C,CAAC;CACF;AAzPC;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;qDAGhB,GAAG;;mCAKZ;AASD;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;;;sCAKzB;AAUD;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;;;iCAGzB;AAuBD;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;;;gCAGzB;AAmCD;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;;;yCAGzB;AAUD;IAFC,iBAAU,CAAC,gFAAgF,CAAC;IAC7F,0BAA0B;;;;;gCAczB;AAuBD;IAFC,iBAAU,CAAC,gDAAgD,CAAC;IAC7D,0BAA0B;;;;;gCAGzB;AAOD;IAFC,iBAAU,CAAC,iBAAiB,CAAC;IAC9B,0BAA0B;;;;;iCAOzB;AA8BD;IAFC,iBAAU,CAAC,uCAAuC,CAAC;IACpD,0BAA0B;;;;;oCAGzB;AA2DD;IAFC,iBAAU,CAAC,uCAAuC,CAAC;IACpD,0BAA0B;;;;;oCAGzB;AAvuBH,0CAwuBC;AAED;;GAEG;AACH,kCAAe,CAAC,eAAe,CAAC,CAAC","file":"InjectorService.js","sourcesContent":["import {\n  Deprecated,\n  Env,\n  getClass,\n  getClassOrSymbol,\n  Metadata,\n  nameOf,\n  promiseTimeout,\n  prototypeOf,\n  RegistryKey,\n  Store,\n  Type\n} from \"@tsed/core\";\nimport {$log} from \"ts-log-debug\";\nimport {ServerSettingsService} from \"../../config/services/ServerSettingsService\";\nimport {Provider} from \"../class/Provider\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {InjectionScopeError} from \"../errors/InjectionScopeError\";\nimport {IInjectableMethod, IProvider, ProviderScope} from \"../interfaces\";\nimport {IInjectableProperties, IInjectablePropertyService, IInjectablePropertyValue} from \"../interfaces/IInjectableProperties\";\nimport {ProviderType} from \"../interfaces/ProviderType\";\nimport {GlobalProviders, ProviderRegistry, registerFactory, registerProvider, registerService} from \"../registries/ProviderRegistry\";\n\nlet globalInjector: any;\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/common\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n * injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n *\n * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.\n *\n */\nexport class InjectorService extends Map<RegistryKey, Provider<any>> {\n  constructor() {\n    super();\n    globalInjector = this;\n    this.initInjector();\n    this.initSettings();\n  }\n\n  get settings() {\n    return this.getProvider(ServerSettingsService)!.instance;\n  }\n\n  /**\n   *\n   */\n  private initInjector() {\n    this.forkProvider(InjectorService, this);\n  }\n\n  /**\n   *\n   */\n  private initSettings() {\n    const provider = GlobalProviders.get(ServerSettingsService)!;\n\n    this.forkProvider(ServerSettingsService, this.invoke<ServerSettingsService>(provider.useClass));\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param target The class or symbol registered in InjectorService.\n   * @returns {boolean}\n   */\n  get<T>(target: Type<T> | symbol | any): T | undefined {\n    return (super.has(target) && super.get(getClassOrSymbol(target))!.instance) || undefined;\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key\n   * @returns {boolean}\n   */\n  has(key: RegistryKey): boolean {\n    return super.has(getClassOrSymbol(key)) && !!this.get(key);\n  }\n\n  /**\n   * The getProvider() method returns a specified element from a Map object.\n   * @param key Required. The key of the element to return from the Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   */\n  getProvider(key: RegistryKey): Provider<any> | undefined {\n    return super.get(getClassOrSymbol(key));\n  }\n\n  /**\n   *\n   * @param {RegistryKey} key\n   * @param instance\n   */\n  forkProvider(key: RegistryKey, instance?: any): Provider<any> {\n    const provider = GlobalProviders.get(key)!.clone();\n    this.set(key, provider);\n\n    provider.instance = instance;\n\n    return provider;\n  }\n\n  /**\n   *\n   * @param {ProviderType} type\n   * @returns {[RegistryKey , Provider<any>][]}\n   */\n  getProviders(type?: ProviderType | string): Provider<any>[] {\n    return Array.from(this)\n      .filter(([key, provider]) => (type ? provider.type === type : true))\n      .map(([key, provider]) => provider);\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param target The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param designParamTypes Optional object. List of injectable types.\n   * @param requiredScope\n   * @returns {T} The class constructed.\n   */\n  invoke<T>(target: any, locals: Map<string | Function, any> = new Map(), designParamTypes?: any[], requiredScope: boolean = false): T {\n    const {onInvoke} = GlobalProviders.getRegistrySettings(target);\n    const provider = this.getProvider(target);\n    const parentScope = Store.from(target).get(\"scope\");\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(target);\n    }\n\n    if (provider && onInvoke) {\n      onInvoke(provider, locals, designParamTypes);\n    }\n\n    const services = designParamTypes.map(serviceType =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope,\n        parentScope\n      })\n    );\n\n    const instance = new target(...services);\n\n    this.bindInjectableProperties(instance);\n\n    return instance;\n  }\n\n  /**\n   *\n   * @returns {any}\n   * @param options\n   */\n  private mapServices(options: any) {\n    const {serviceType, target, locals, parentScope, requiredScope} = options;\n    const serviceName = typeof serviceType === \"function\" ? nameOf(serviceType) : serviceType;\n    const localService = locals.get(serviceName) || locals.get(serviceType);\n\n    if (localService) {\n      return localService;\n    }\n\n    const provider = this.getProvider(serviceType);\n\n    if (!provider) {\n      throw new InjectionError(target, serviceName.toString());\n    }\n\n    const {buildable, injectable} = GlobalProviders.getRegistrySettings(provider.type);\n    const scopeReq = provider.scope === ProviderScope.REQUEST;\n\n    if (!injectable) {\n      throw new InjectionError(target, serviceName.toString(), \"not injectable\");\n    }\n\n    if (!buildable || (provider.instance && !scopeReq)) {\n      return provider.instance;\n    }\n\n    if (scopeReq && requiredScope && !parentScope) {\n      throw new InjectionScopeError(provider.useClass, target);\n    }\n\n    try {\n      const instance = this.invoke<any>(provider.useClass, locals, undefined, requiredScope);\n\n      if (!scopeReq) {\n        locals.set(provider.provide, instance);\n      }\n\n      return instance;\n    } catch (er) {\n      const error = new InjectionError(target, serviceName.toString(), \"injection failed\");\n      (error as any).origin = er;\n      throw error;\n    }\n  }\n\n  /**\n   *\n   * @param instance\n   */\n  private bindInjectableProperties(instance: any) {\n    const properties: IInjectableProperties = Store.from(getClass(instance)).get(\"injectableProperties\") || [];\n\n    Object.keys(properties)\n      .map(key => properties[key])\n      .forEach(definition => {\n        switch (definition.bindingType) {\n          case \"method\":\n            this.bindMethod(instance, definition);\n            break;\n          case \"property\":\n            this.bindProperty(instance, definition);\n            break;\n          case \"constant\":\n            this.bindConstant(instance, definition);\n            break;\n          case \"value\":\n            this.bindValue(instance, definition);\n            break;\n          case \"custom\":\n            definition.onInvoke(this, instance, definition);\n            break;\n        }\n      });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  private bindMethod(instance: any, {propertyKey}: IInjectablePropertyService) {\n    const target = getClass(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (locals: Map<Function, string> | any = new Map<Function, string>()) => {\n      return this.invokeMethod(originalMethod!.bind(instance), {\n        target,\n        methodName: propertyKey,\n        locals: locals instanceof Map ? locals : undefined\n      });\n    };\n\n    instance[propertyKey].$injected = true;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindProperty(instance: any, {propertyKey, useType}: IInjectablePropertyService) {\n    Object.defineProperty(instance, propertyKey, {\n      get: () => {\n        return this.get(useType);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindValue(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  private bindConstant(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const clone = (o: any) => {\n      if (o) {\n        return Object.freeze(JSON.parse(JSON.stringify(o)));\n      }\n\n      return defaultValue;\n    };\n\n    const descriptor = {\n      get: () => clone(this.settings.get(expression)),\n\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n\n    return descriptor;\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * class MyService {\n   *      constructor(injectorService: InjectorService) {\n   *          injectorService.invokeMethod(this.method, {\n   *              this,\n   *              methodName: 'method'\n   *          });\n   *      }\n   *\n   *   method(otherService: OtherService) {}\n   * }\n   * ```\n   *\n   * @returns {any}\n   * @param handler The injectable method to invoke. Method parameters are injected according method signature.\n   * @param options Object to configure the invocation.\n   */\n  public invokeMethod(handler: any, options: IInjectableMethod<any>): any {\n    let {designParamTypes} = options;\n    const {locals = new Map<any, any>(), target, methodName} = options;\n\n    if (handler.$injected) {\n      return handler.call(target, locals);\n    }\n\n    if (!designParamTypes) {\n      designParamTypes = Metadata.getParamTypes(prototypeOf(target), methodName);\n    }\n\n    const services = designParamTypes.map((serviceType: any) =>\n      this.mapServices({\n        serviceType,\n        target,\n        locals,\n        requiredScope: false,\n        parentScope: false\n      })\n    );\n\n    return handler(...services);\n  }\n\n  /**\n   * Initialize injectorService and load all services/factories.\n   */\n  async load(): Promise<any> {\n    // TODO copy all provider from GlobalProvider registry. In future this action will be performed from Bootstrap class\n    GlobalProviders.forEach((p, k) => {\n      if (!this.has(k)) {\n        this.set(k, p.clone());\n      }\n    });\n\n    this.build();\n\n    return Promise.all([this.emit(\"$onInit\")]);\n  }\n\n  /**\n   *\n   * @returns {Map<Type<any>, any>}\n   */\n  private build(): Map<Type<any>, any> {\n    const locals: Map<Type<any>, any> = new Map();\n    const config = this.get<ServerSettingsService>(ServerSettingsService)!;\n\n    this.forEach(provider => {\n      const token = nameOf(provider.provide);\n      const settings = GlobalProviders.getRegistrySettings(provider.type);\n      const useClass = nameOf(provider.useClass);\n\n      if (settings.buildable) {\n        const defaultScope: ProviderScope = config.get(`${provider.type}Scope`) || ProviderScope.SINGLETON;\n\n        if (defaultScope && !provider.scope) {\n          provider.scope = defaultScope;\n        }\n\n        if (!locals.has(provider.provide)) {\n          provider.instance = this.invoke(provider.useClass, locals);\n          $log.debug(nameOf(provider.provide), \"built\", token === useClass ? \"\" : `from class ${useClass}`);\n        }\n      } else {\n        provider.scope = ProviderScope.SINGLETON;\n        $log.debug(nameOf(provider.provide), \"loaded\");\n      }\n\n      if (provider.instance) {\n        locals.set(provider.provide, provider.instance);\n      }\n    });\n\n    return locals;\n  }\n\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](docs/services/lifecycle-hooks.md).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  public emit(eventName: string, ...args: any[]) {\n    const promises: Promise<any>[] = [];\n\n    $log.debug(\"\\x1B[1mCall hook\", eventName, \"\\x1B[22m\");\n\n    this.forEach(provider => {\n      const service = provider.instance;\n\n      if (service && eventName in service) {\n        /* istanbul ignore next */\n        if (eventName === \"$onInjectorReady\") {\n          $log.warn(\"$onInjectorReady hook is deprecated, use $onInit hook insteadof. See https://goo.gl/KhvkVy\");\n        }\n\n        const promise: any = service[eventName](...args);\n\n        /* istanbul ignore next */\n        if (promise && promise.then) {\n          promises.push(\n            promiseTimeout(promise, 1000).then(result => InjectorService.checkPromiseStatus(eventName, result, nameOf(provider.useClass)))\n          );\n        }\n      }\n    });\n\n    /* istanbul ignore next */\n    if (promises.length) {\n      $log.debug(\"\\x1B[1mCall hook\", eventName, \" promises built\\x1B[22m\");\n\n      return promiseTimeout(Promise.all(promises), 2000).then(result => InjectorService.checkPromiseStatus(eventName, result));\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   *\n   * @param {string} eventName\n   * @param result\n   * @param {string} service\n   */\n\n  /* istanbul ignore next */\n  private static checkPromiseStatus(eventName: string, result: any, service?: string) {\n    if (!result.ok) {\n      const msg = `Timeout on ${eventName} hook. Promise are unfulfilled ${service ? \"on service\" + service : \"\"}`;\n      if (process.env.NODE_ENV === Env.PROD) {\n        throw msg;\n      } else {\n        setTimeout(() => $log.warn(msg, \"In production, the warning will down the server!\"), 1000);\n      }\n    }\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param target The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param designParamTypes Optional object. List of injectable types.\n   * @param requiredScope\n   * @returns {T} The class constructed.\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static invoke<T>(\n    target: any,\n    locals: Map<string | Function, any> = new Map<Function, any>(),\n    designParamTypes?: any[],\n    requiredScope: boolean = false\n  ): T {\n    return globalInjector.invoke(target, locals, designParamTypes, requiredScope);\n  }\n\n  /**\n   * Construct the service with his dependencies.\n   * @param target The service to be built.\n   * @deprecated\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static construct<T>(target: Type<any> | symbol): T {\n    const provider: Provider<any> = ProviderRegistry.get(target)!;\n\n    return this.invoke<any>(provider.useClass);\n  }\n\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](docs/services/lifecycle-hooks.md).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static async emit(eventName: string, ...args: any[]): Promise<any> {\n    return globalInjector.emit(eventName, args);\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param target The class or symbol registered in InjectorService.\n   * @returns {boolean}\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static get<T>(target: RegistryKey): T {\n    return globalInjector.get(target)!.instance;\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * class MyService {\n   *      constructor(injectorService: InjectorService) {\n   *          injectorService.invokeMethod(this.method.bind(this), {\n   *              target: this,\n   *              methodName: 'method'\n   *          });\n   *      }\n   *\n   *   method(otherService: OtherService) {}\n   * }\n   * ```\n   *\n   * @returns {any}\n   * @param handler The injectable method to invoke. Method parameters are injected according method signature.\n   * @param options Object to configure the invocation.\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static invokeMethod(handler: any, options: IInjectableMethod<any> | any[]) {\n    return globalInjector.invokeMethod(handler, options);\n  }\n\n  /**\n   * Set a new provider from providerSetting.\n   * @param provider provide token.\n   * @param instance Instance\n   * @deprecated Use registerProvider or registerService or registerFactory instead of\n   */\n  @Deprecated(\"Use registerService(), registerFactory() or registerProvider() util instead of\")\n  /* istanbul ignore next */\n  static set(provider: IProvider<any> | any, instance?: any) {\n    if (!provider.provide) {\n      provider = {\n        provide: provider,\n        type: \"factory\",\n        useClass: provider,\n        instance: instance || provider\n      };\n    }\n\n    registerProvider(provider);\n\n    return InjectorService;\n  }\n\n  /**\n   * Check if the service of factory exists in `InjectorService`.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *    constructor(injectorService: InjectorService) {\n   *        const exists = injectorService.has(MyService); // true or false\n   *    }\n   * }\n   * ```\n   *\n   * @param target The service class\n   * @returns {boolean}\n   */\n  @Deprecated(\"static InjectorService.has(). Removed feature.\")\n  /* istanbul ignore next */\n  static has(target: any): boolean {\n    return globalInjector.has(target);\n  }\n\n  /**\n   * Initialize injectorService and load all services/factories.\n   */\n  @Deprecated(\"removed feature\")\n  /* istanbul ignore next */\n  static async load() {\n    if (!globalInjector) {\n      globalInjector = new InjectorService();\n    }\n\n    return globalInjector.load();\n  }\n\n  /**\n   * Add a new service in the registry. This service will be constructed when `InjectorService`will loaded.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * export default class MyFooService {\n   *     constructor(){}\n   *     getFoo() {\n   *         return \"test\";\n   *     }\n   * }\n   *\n   * InjectorService.service(MyFooService);\n   * const injector = new InjectorService();\n   * injector.load();\n   *\n   * const myFooService = injector.get<MyFooService>(MyFooService);\n   * myFooService.getFoo(); // test\n   * ```\n   *\n   * @param target The class to add in registry.\n   * @deprecated Use registerService or registerFactory instead of.\n   */\n  @Deprecated(\"Use registerService() util instead of\")\n  /* istanbul ignore next */\n  static service(target: any) {\n    return registerService(target);\n  }\n\n  /**\n   * Add a new factory in `InjectorService` registry.\n   *\n   * #### Example with symbol definition\n   *\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * export interface IMyFooFactory {\n   *    getFoo(): string;\n   * }\n   *\n   * export type MyFooFactory = IMyFooFactory;\n   * export const MyFooFactory = Symbol(\"MyFooFactory\");\n   *\n   * InjectorService.factory(MyFooFactory, {\n   *      getFoo:  () => \"test\"\n   * });\n   *\n   * @Service()\n   * export class OtherService {\n   *      constructor(@Inject(MyFooFactory) myFooFactory: MyFooFactory){\n   *          console.log(myFooFactory.getFoo()); /// \"test\"\n   *      }\n   * }\n   * ```\n   *\n   * > Note: When you use the factory method with Symbol definition, you must use the `@Inject()`\n   * decorator to retrieve your factory in another Service. Advice: By convention all factory class name will be prefixed by\n   * `Factory`.\n   *\n   * #### Example with class\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   *\n   * export class MyFooService {\n   *  constructor(){}\n   *      getFoo() {\n   *          return \"test\";\n   *      }\n   * }\n   *\n   * InjectorService.factory(MyFooService, new MyFooService());\n   *\n   * @Service()\n   * export class OtherService {\n   *      constructor(myFooService: MyFooService){\n   *          console.log(myFooFactory.getFoo()); /// \"test\"\n   *      }\n   * }\n   * ```\n   * @deprecated Use registerFactory instead of\n   */\n  @Deprecated(\"Use registerFactory() util instead of\")\n  /* istanbul ignore next */\n  static factory(target: any, instance: any) {\n    return registerFactory(target, instance);\n  }\n}\n\n/**\n * Create the first service InjectorService\n */\nregisterFactory(InjectorService);\n"],"sourceRoot":"../../../"}