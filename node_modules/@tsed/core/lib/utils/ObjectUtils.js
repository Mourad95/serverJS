"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Get the provide constructor.
 * @param targetClass
 */
exports.getConstructor = (targetClass) => (typeof targetClass === "function" ? targetClass : targetClass.constructor);
/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 */
function getClass(target) {
    return target.prototype ? target : target.constructor;
}
exports.getClass = getClass;
/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 * @alias getClass
 */
function classOf(target) {
    return getClass(target);
}
exports.classOf = classOf;
/**
 *
 * @param target
 * @returns {symbol}
 */
function getClassOrSymbol(target) {
    return typeof target === "symbol" ? target : getClass(target);
}
exports.getClassOrSymbol = getClassOrSymbol;
/**
 * Return true if the given obj is a primitive.
 * @param target
 * @returns {boolean}
 */
function isPrimitiveOrPrimitiveClass(target) {
    return isString(target) || isNumber(target) || isBoolean(target);
}
exports.isPrimitiveOrPrimitiveClass = isPrimitiveOrPrimitiveClass;
/**
 *
 * @param target
 * @returns {"string" | "number" | "boolean" | "any"}
 */
function primitiveOf(target) {
    if (isString(target)) {
        return "string";
    }
    if (isNumber(target)) {
        return "number";
    }
    if (isBoolean(target)) {
        return "boolean";
    }
    return "any";
}
exports.primitiveOf = primitiveOf;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isString(target) {
    return typeof target === "string" || target instanceof String || target === String;
}
exports.isString = isString;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isNumber(target) {
    return typeof target === "number" || target instanceof Number || target === Number;
}
exports.isNumber = isNumber;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isBoolean(target) {
    return typeof target === "boolean" || target instanceof Boolean || target === Boolean;
}
exports.isBoolean = isBoolean;
/**
 *
 * @param target
 * @returns {Boolean}
 */
function isArray(target) {
    return Array.isArray(target);
}
exports.isArray = isArray;
/**
 * Return true if the clazz is an array.
 * @param target
 * @returns {boolean}
 */
function isArrayOrArrayClass(target) {
    if (target === Array) {
        return true;
    }
    return isArray(target);
}
exports.isArrayOrArrayClass = isArrayOrArrayClass;
/**
 * Return true if the target.
 * @param target
 * @returns {boolean}
 */
function isCollection(target) {
    return (isArrayOrArrayClass(target) ||
        target === Map ||
        target instanceof Map ||
        target === Set ||
        target instanceof Set ||
        target === WeakMap ||
        target instanceof WeakMap ||
        target === WeakSet ||
        target instanceof WeakSet);
}
exports.isCollection = isCollection;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isDate(target) {
    return target === Date || target instanceof Date;
}
exports.isDate = isDate;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isObject(target) {
    return target === Object;
}
exports.isObject = isObject;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isClass(target) {
    return !isPrimitiveOrPrimitiveClass(target) && !isObject(target) && !isDate(target) && target !== undefined && !isPromise(target);
}
exports.isClass = isClass;
/**
 * Return true if the value is an empty string, null or undefined.
 * @param value
 * @returns {boolean}
 */
function isEmpty(value) {
    return value === "" || value === null || value === undefined;
}
exports.isEmpty = isEmpty;
/**
 *
 * @param target
 * @returns {boolean}
 */
function isPromise(target) {
    return target === Promise || target instanceof Promise;
}
exports.isPromise = isPromise;
/**
 *
 * @param target
 * @returns {any}
 */
function getInheritedClass(target) {
    return Object.getPrototypeOf(target);
}
exports.getInheritedClass = getInheritedClass;
/**
 *
 * @param target
 * @returns {Array}
 */
function ancestorsOf(target) {
    const classes = [];
    let currentTarget = getClass(target);
    while (nameOf(currentTarget) !== "") {
        classes.unshift(currentTarget);
        currentTarget = getInheritedClass(currentTarget);
    }
    return classes;
}
exports.ancestorsOf = ancestorsOf;
/**
 * Get object name
 */
function nameOf(obj) {
    switch (typeof obj) {
        default:
            return "" + obj;
        case "symbol":
            return exports.nameOfSymbol(obj);
        case "function":
            return nameOfClass(obj);
    }
}
exports.nameOf = nameOf;
/**
 * Get the provide name.
 * @param targetClass
 */
function nameOfClass(targetClass) {
    return typeof targetClass === "function" ? targetClass.name : targetClass.constructor.name;
}
exports.nameOfClass = nameOfClass;
/**
 * Get symbol name.
 * @param sym
 */
exports.nameOfSymbol = (sym) => sym
    .toString()
    .replace("Symbol(", "")
    .replace(")", "");
/**
 *
 * @param target
 * @param {string} propertyKey
 * @returns {PropertyDescriptor}
 */
function descriptorOf(target, propertyKey) {
    return Object.getOwnPropertyDescriptor((target && target.prototype) || target, propertyKey);
}
exports.descriptorOf = descriptorOf;
/**
 *
 * @param target
 * @returns {any}
 */
function prototypeOf(target) {
    return classOf(target) === target ? target.prototype : target;
}
exports.prototypeOf = prototypeOf;

//# sourceMappingURL=ObjectUtils.js.map
