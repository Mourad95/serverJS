"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const Express = require("express");
const ts_httpexceptions_1 = require("ts-httpexceptions");
const error_1 = require("../../filters/decorators/error");
const request_1 = require("../../filters/decorators/request");
const response_1 = require("../../filters/decorators/response");
const middlewareError_1 = require("../decorators/class/middlewareError");
/**
 * @middleware
 */
let GlobalErrorHandlerMiddleware = class GlobalErrorHandlerMiddleware {
    constructor(settingsServerService) {
        const { headerName = "errors" } = settingsServerService.errors;
        this.headerName = headerName;
    }
    use(error, request, response) {
        const toHTML = (message = "") => message.replace(/\n/gi, "<br />");
        if (error instanceof ts_httpexceptions_1.Exception || error.status) {
            request.log.error({
                error: {
                    message: error.message,
                    stack: error.stack,
                    status: error.status,
                    origin: error.origin
                }
            });
            this.setHeaders(response, error, error.origin);
            response.status(error.status).send(toHTML(error.message));
            return;
        }
        if (typeof error === "string") {
            response.status(404).send(toHTML(error));
            return;
        }
        request.log.error({
            error: {
                status: 500,
                message: error.message,
                stack: error.stack,
                origin: error.origin
            }
        });
        this.setHeaders(response, error, error.origin);
        response.status(error.status || 500).send("Internal Error");
        return;
    }
    /**
     *
     * @param {e.Response} response
     * @param args
     */
    setHeaders(response, ...args) {
        let hErrors = [];
        args.filter(o => !!o).forEach(({ headers, errors }) => {
            if (headers) {
                response.set(headers);
            }
            if (errors) {
                hErrors = hErrors.concat(errors);
            }
        });
        if (hErrors.length) {
            response.set(this.headerName, JSON.stringify(hErrors));
        }
    }
};
tslib_1.__decorate([
    tslib_1.__param(0, error_1.Err()), tslib_1.__param(1, request_1.Request()), tslib_1.__param(2, response_1.Response()),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Object)
], GlobalErrorHandlerMiddleware.prototype, "use", null);
GlobalErrorHandlerMiddleware = tslib_1.__decorate([
    middlewareError_1.MiddlewareError(),
    tslib_1.__metadata("design:paramtypes", [common_1.ServerSettingsService])
], GlobalErrorHandlerMiddleware);
exports.GlobalErrorHandlerMiddleware = GlobalErrorHandlerMiddleware;

//# sourceMappingURL=GlobalErrorHandlerMiddleware.js.map
