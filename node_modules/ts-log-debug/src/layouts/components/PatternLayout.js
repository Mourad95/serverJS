"use strict";
/**
 * @module layouts
 */
/** */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var StringUtils_1 = require("../utils/StringUtils");
var BaseLayout_1 = require("../class/BaseLayout");
var LayoutReplacer_1 = require("../class/LayoutReplacer");
var layout_1 = require("../decorators/layout");
var regex = /%(-?[0-9]+)?(\.?[0-9]+)?([[\]cdhmnprzxy%])(\{([^}]+)\})?|([^%]+)/;
var TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
/**
 * PatternLayout
 * Format for specifiers is %[padding].[truncation][field]{[format]}
 * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10
 * Fields can be any of:
 *  - %r time in toLocaleTimeString format
 *  - %p log level
 *  - %c log category
 *  - %h hostname
 *  - %m log data
 *  - %d date in constious formats
 *  - %% %
 *  - %n newline
 *  - %z pid
 *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter
 * You can use %[ and %] to define a colored block.
 *
 * Tokens are specified as simple key:value objects.
 * The key represents the token name whereas the value can be a string or function
 * which is called to extract the value to put in the log message. If token is not
 * found, it doesn't replace the field.
 *
 * A sample token would be: { 'pid' : function() { return process.pid; } }
 *
 * Takes a pattern string, array of tokens and returns a layouts function.
 * @return {Function}
 * @param pattern
 * @param tokens
 * @param timezoneOffset
 *
 * @authors ['Stephan Strittmatter', 'Jan Schmidle']
 */
var PatternLayout = /** @class */ (function (_super) {
    tslib_1.__extends(PatternLayout, _super);
    function PatternLayout(config) {
        var _this = _super.call(this, config) || this;
        _this.replaceToken = function (conversionCharacter, loggingEvent, specifier) {
            return _this._replacers[conversionCharacter](loggingEvent, specifier);
        };
        _this.pattern = config && config.pattern || TTCC_CONVERSION_PATTERN;
        _this.tokens = config && config.tokens;
        _this._replacers = new LayoutReplacer_1.LayoutReplacer(_this.tokens, _this.config.timezoneOffset).build();
        return _this;
    }
    /**
     *
     * @param loggingEvent
     * @param timezoneOffset
     * @returns {string}
     */
    PatternLayout.prototype.transform = function (loggingEvent, timezoneOffset) {
        var formattedString = "";
        var result;
        var searchString = this.pattern;
        /* eslint no-cond-assign:0 */
        while ((result = regex.exec(searchString)) !== null) {
            // const matchedString = result[0];
            var padding = result[1];
            var truncation = result[2];
            var conversionCharacter = result[3];
            var specifier = result[5];
            var text = result[6];
            // Check if the pattern matched was just normal text
            if (text) {
                formattedString += text.toString();
            }
            else {
                // Create a raw replacement string based on the conversion
                // character and specifier
                var replacement = this.replaceToken(conversionCharacter, loggingEvent, specifier);
                formattedString += StringUtils_1.truncateAndPad(replacement, truncation, padding);
            }
            searchString = searchString.substr(result.index + result[0].length);
        }
        return formattedString;
    };
    PatternLayout = tslib_1.__decorate([
        layout_1.Layout({ name: "pattern" }),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], PatternLayout);
    return PatternLayout;
}(BaseLayout_1.BaseLayout));
exports.PatternLayout = PatternLayout;
//# sourceMappingURL=PatternLayout.js.map