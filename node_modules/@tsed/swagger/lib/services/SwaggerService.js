"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const Express = require("express");
const Fs = require("fs");
const PathUtils = require("path");
const ts_log_debug_1 = require("ts-log-debug");
const OpenApiEndpointBuilder_1 = require("../class/OpenApiEndpointBuilder");
const utils_1 = require("../utils");
const swaggerUiPath = require("swagger-ui-dist").absolutePath();
const ejs = require("ejs");
let SwaggerService = class SwaggerService {
    constructor(controllerService, serverSettingsService, expressApplication) {
        this.controllerService = controllerService;
        this.serverSettingsService = serverSettingsService;
        this.expressApplication = expressApplication;
        this.OPERATION_IDS = {};
        this.getOperationId = (operationId) => {
            if (this.OPERATION_IDS[operationId] !== undefined) {
                this.OPERATION_IDS[operationId]++;
                operationId = operationId + "_" + this.OPERATION_IDS[operationId];
            }
            else {
                this.OPERATION_IDS[operationId] = 0;
            }
            return operationId;
        };
        this.rand = Math.random();
    }
    /**
     *
     */
    $afterRoutesInit() {
        const swagger = [].concat(this.serverSettingsService.get("swagger")).filter(o => !!o);
        const urls = swagger.reduce((acc, conf) => {
            const { path = "/", doc, hidden } = conf;
            if (!hidden) {
                acc.push({ url: `${path}/swagger.json`, name: doc || path });
            }
            return acc;
        }, []);
        swagger.forEach((conf) => {
            const { path = "/", options = {}, outFile, showExplorer, cssPath, jsPath } = conf;
            const spec = this.getOpenAPISpec(conf);
            const scope = {
                spec,
                url: `${path}/swagger.json`,
                urls,
                showExplorer,
                cssPath,
                jsPath,
                swaggerOptions: options
            };
            this.expressApplication.get(path, this.middlewareRedirect(path));
            this.expressApplication.use(path, this.createRouter(conf, scope));
            if (outFile) {
                Fs.writeFileSync(outFile, JSON.stringify(spec, null, 2));
            }
        });
    }
    $onServerReady() {
        const host = this.serverSettingsService.getHttpPort();
        const swagger = [].concat(this.serverSettingsService.get("swagger")).filter(o => !!o);
        swagger.forEach((conf) => {
            const { path = "/", doc } = conf;
            ts_log_debug_1.$log.info(`[${doc || "default"}] Swagger JSON is available on http://${host.address}:${host.port}${path}/swagger.json`);
            ts_log_debug_1.$log.info(`[${doc || "default"}] Swagger UI is available on http://${host.address}:${host.port}${path}/`);
        });
    }
    /**
     *
     * @param {ISwaggerSettings} conf
     * @param scope
     */
    createRouter(conf, scope) {
        const { cssPath, jsPath } = conf;
        const router = Express.Router();
        router.get("/", this.middlewareIndex(scope));
        router.get("/swagger.json", (req, res) => res.status(200).json(scope.spec));
        router.use(Express.static(swaggerUiPath));
        if (cssPath) {
            router.get("/main.css", this.middlewareCss(cssPath));
        }
        if (jsPath) {
            router.get("/main.js", this.middlewareJs(jsPath));
        }
        return router;
    }
    middlewareRedirect(path) {
        /* istanbul ignore next */
        return (req, res, next) => {
            if (req.url === path && !req.url.match(/\/$/)) {
                res.redirect(path + "/");
            }
            else {
                next();
            }
        };
    }
    /**
     *
     * @param scope
     * @returns {(req: any, res: any) => any}
     */
    middlewareIndex(scope) {
        /* istanbul ignore next */
        return (req, res) => ejs.renderFile(__dirname + "/../views/index.ejs", scope, {}, (err, str) => {
            if (err) {
                ts_log_debug_1.$log.error(err);
                res.status(500).send(err.message);
            }
            else {
                res.send(str);
            }
        });
    }
    /**
     *
     * @param {e.Router} router
     * @param {string} path
     */
    middlewareCss(path) {
        /* istanbul ignore next */
        return (req, res) => {
            const content = Fs.readFileSync(PathUtils.resolve(this.serverSettingsService.resolve(path)), { encoding: "utf8" });
            res.set("Content-Type", "text/css");
            res.status(200).send(content);
        };
    }
    /**
     *
     * @param {e.Router} router
     * @param {string} path
     */
    middlewareJs(path) {
        /* istanbul ignore next */
        return (req, res) => {
            const content = Fs.readFileSync(PathUtils.resolve(this.serverSettingsService.resolve(path)), { encoding: "utf8" });
            res.set("Content-Type", "application/javascript");
            res.status(200).send(content);
        };
    }
    /**
     *
     * @returns {Spec}
     */
    getOpenAPISpec(conf) {
        const defaultSpec = this.getDefaultSpec(conf);
        const paths = {};
        const definitions = {};
        const doc = conf.doc;
        const tags = [];
        this.OPERATION_IDS = {};
        this.controllerService.routes.forEach(({ provider, route }) => {
            const hidden = provider.store.get("hidden");
            const docs = provider.store.get("docs") || [];
            if ((!doc && !hidden) || (doc && docs.indexOf(doc) > -1)) {
                this.buildRoutes(paths, definitions, provider, route);
                tags.push(this.buildTags(provider));
            }
        });
        return core_1.deepExtends(defaultSpec, {
            tags,
            paths,
            definitions
        }, utils_1.getReducers());
    }
    readSpecPath(path) {
        path = this.serverSettingsService.resolve(path);
        if (Fs.existsSync(path)) {
            const json = Fs.readFileSync(path, { encoding: "utf8" });
            /* istanbul ignore else */
            if (json !== "") {
                return JSON.parse(json);
            }
        }
        return {};
    }
    /**
     * Return the global api information.
     * @returns {Info}
     */
    getDefaultSpec(conf) {
        const { version } = this.serverSettingsService;
        const consumes = this.serverSettingsService.acceptMimes;
        const produces = ["application/json"];
        const { spec = {
            info: {},
            securityDefinitions: {}
        }, specPath } = conf || {};
        let specPathContent = {};
        if (specPath) {
            specPathContent = this.readSpecPath(specPath);
        }
        /* istanbul ignore next */
        const { title = "Api documentation", description = "", version: versionInfo, termsOfService = "", contact, license } = spec.info || {};
        return core_1.deepExtends({
            swagger: "2.0",
            info: {
                version: versionInfo || version,
                title,
                description,
                termsOfService,
                contact,
                license
            },
            consumes,
            produces,
            securityDefinitions: spec.securityDefinitions || {}
        }, specPathContent, utils_1.getReducers());
    }
    /**
     *
     * @param paths
     * @param definitions
     * @param ctrl
     * @param endpointUrl
     */
    buildRoutes(paths, definitions, ctrl, endpointUrl) {
        ctrl.dependencies.map(ctrl => this.controllerService.get(ctrl)).forEach((provider) => {
            if (!provider.store.get("hidden")) {
                this.buildRoutes(paths, definitions, provider, `${endpointUrl}${provider.path}`);
            }
        });
        ctrl.endpoints.forEach((endpoint) => {
            if (endpoint.store.get("hidden")) {
                return;
            }
            endpoint.pathsMethods.forEach(pathMethod => {
                /* istanbul ignore else */
                if (!!pathMethod.method) {
                    const builder = new OpenApiEndpointBuilder_1.OpenApiEndpointBuilder(endpoint, endpointUrl, pathMethod, this.getOperationId).build();
                    core_1.deepExtends(paths, builder.paths);
                    core_1.deepExtends(definitions, builder.definitions);
                }
            });
        });
    }
    buildTags(ctrl) {
        const clazz = ctrl.useClass;
        const ctrlStore = core_1.Store.from(clazz);
        return Object.assign({
            name: ctrlStore.get("name") || core_1.nameOf(clazz),
            description: ctrlStore.get("description")
        }, ctrlStore.get("tag") || {});
    }
};
SwaggerService = tslib_1.__decorate([
    common_1.Service(),
    tslib_1.__param(2, common_1.ExpressApplication),
    tslib_1.__metadata("design:paramtypes", [common_1.ControllerService,
        common_1.ServerSettingsService, Function])
], SwaggerService);
exports.SwaggerService = SwaggerService;

//# sourceMappingURL=SwaggerService.js.map
