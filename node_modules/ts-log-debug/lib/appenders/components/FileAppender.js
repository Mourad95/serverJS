"use strict";
/**
 * @module appenders
 */
/** */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var appender_1 = require("../decorators/appender");
var Path = require("path");
var Os = require("os");
var BaseAppender_1 = require("../class/BaseAppender");
var streams = require("streamroller");
var eol = Os.EOL || "\n";
/**
 * ## File Appender
 *
 * The file appender writes log events to a file. It supports an optional maximum file size, and will keep a configurable number of backups. When using the file appender, you should also call ts-log-debug.shutdown() when your application terminates, to ensure that any remaining asynchronous writes have finished. Although the file appender uses the streamroller library, this is included as a dependency of ts-log-debug so you do not need to include it yourself.
 *
 * ## Configuration
 *
 * * type - "file"
 * * filename - string - the path of the file where you want your logs written.
 * * maxLogSize - integer (optional) - the maximum size (in bytes) for the log file. If not specified, then no log rolling will happen.
 * * backups - integer (optional, default value = 5) - the number of old log files to keep during log rolling.
 * * layout - (optional, defaults to basic layout) - see layouts
 *
 * Any other configuration parameters will be passed to the underlying streamroller implementation (see also node.js core file streams):
 *
 * * encoding - string (default “utf-8”)
 * * mode - integer (default 0644)
 * * flags - string (default ‘a’)
 * * compress - boolean (default false) - compress the backup files during rolling (backup files will have .gz extension)
 *
 * ## Example
 *
 * ```typescript
 * import {Logger} from "ts-log-debug";
 *
 * const logger = new Logger("loggerName");
 *
 * logger.appenders.set("log-file", {
 *     type: "file",
 *     filename: "all-the-logs.log"
 * });
 * logger.debug('I will be logged in all-the-logs.log');
 * ```
 * > This example will result in a single log file (all-the-logs.log) containing the log messages.
 *
 * ## Example with log rolling (and compressed backups)
 *
 * ```typescript
 * import {Logger} from "ts-log-debug";
 *
 * const logger = new Logger("loggerName");
 *
 * logger.appenders.set("log-file2", {
 *     type: "file",
 *     filename: "all-the-logs.log",
 *     maxLogSize: 10485760,
 *     backups: 3,
 *     compress: true
 * });
 * logger.debug('I will be logged in all-the-logs.log');
 * ```
 * > This will result in one current log file (all-the-logs.log). When that reaches 10Mb in size, it will be renamed and compressed to all-the-logs.log.1.gz and a new file opened called all-the-logs.log. When all-the-logs.log reaches 10Mb again, then all-the-logs.log.1.gz will be renamed to all-the-logs.log.2.gz, and so on.
 *
 * @private
 */
var FileAppender = /** @class */ (function (_super) {
    tslib_1.__extends(FileAppender, _super);
    function FileAppender() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     */
    FileAppender.prototype.reopen = function () {
        this.writer.closeTheStream(this.writer.openTheStream.bind(this.writer));
    };
    /**
     *
     * @param complete
     */
    FileAppender.prototype.shutdown = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.writer.write("", "utf-8", function () {
                _this.writer.end(resolve);
            });
        });
    };
    /**
     *
     * @param loggingEvent
     */
    FileAppender.prototype.write = function (loggingEvent) {
        this.writer.write(this.layout(loggingEvent, this.config.timezoneOffset) + eol, "utf8");
    };
    FileAppender.prototype.build = function () {
        var _this = this;
        var _a = this.config, file = _a.filename, logSize = _a.maxlogSize, numBackups = _a.backups;
        file = Path.normalize(file);
        numBackups = numBackups === undefined ? 5 : numBackups;
        // there has to be at least one backup if logSize has been specified
        numBackups = numBackups === 0 ? 1 : numBackups;
        this.writer = this.openTheStream(file, logSize, numBackups, this.config);
        // On SIGHUP, close and reopen all files. This allows this appender to work with
        // logrotate. Note that if you are using logrotate, you should not set
        // `logSize`.
        process.on("SIGHUP", function () {
            _this.reopen();
        });
    };
    /**
     *
     * @param file
     * @param fileSize
     * @param numFiles
     * @param options
     * @returns {streams.RollingFileStream}
     */
    FileAppender.prototype.openTheStream = function (file, fileSize, numFiles, options) {
        var stream = new streams.RollingFileStream(file, fileSize, numFiles, options);
        stream.on("error", function (err) {
            console.error("FileAppender - Writing to file %s, error happened ", file, err);
        });
        return stream;
    };
    FileAppender = tslib_1.__decorate([
        appender_1.Appender({ name: "file", defaultLayout: "basic" })
    ], FileAppender);
    return FileAppender;
}(BaseAppender_1.BaseAppender));
exports.FileAppender = FileAppender;
//# sourceMappingURL=FileAppender.js.map