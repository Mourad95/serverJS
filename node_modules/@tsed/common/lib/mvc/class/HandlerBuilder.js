"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const interfaces_1 = require("../../di/interfaces");
const FilterBuilder_1 = require("../../filters/class/FilterBuilder");
const EndpointMetadata_1 = require("./EndpointMetadata");
const HandlerMetadata_1 = require("./HandlerMetadata");
/**
 * @stable
 */
class HandlerBuilder {
    constructor(handlerMetadata) {
        this.handlerMetadata = handlerMetadata;
        this._rebuildHandler = false;
    }
    /**
     *
     * @param obj
     * @returns {HandlerBuilder}
     */
    static from(obj) {
        if (obj instanceof EndpointMetadata_1.EndpointMetadata) {
            // Endpoint
            return new HandlerBuilder(new HandlerMetadata_1.HandlerMetadata(obj.target, obj.methodClassName));
        }
        // Middleware
        return new HandlerBuilder(new HandlerMetadata_1.HandlerMetadata(obj));
    }
    /**
     *
     * @returns {any}
     */
    build(injector) {
        this.injector = injector;
        this.debug = injector.settings.debug;
        this.filters = this.handlerMetadata.services.map((param) => new FilterBuilder_1.FilterBuilder(injector).build(param));
        if (this.handlerMetadata.errorParam) {
            return (err, request, response, next) => this.invoke(request, response, next, err);
        }
        else {
            return (request, response, next) => this.invoke(request, response, next);
        }
    }
    /**
     *
     * @param locals
     * @returns {any}
     */
    buildHandler(locals = new Map()) {
        const provider = this.injector.getProvider(this.handlerMetadata.target);
        /* istanbul ignore next */
        if (!provider) {
            throw new Error(`${core_1.nameOf(this.handlerMetadata.target)} component not found in the injector`);
        }
        const target = provider.useClass;
        let instance = provider.instance;
        this._rebuildHandler = provider.scope !== interfaces_1.ProviderScope.SINGLETON;
        if (this._rebuildHandler || instance === undefined) {
            instance = this.injector.invoke(target, locals, undefined, true);
        }
        return instance[this.handlerMetadata.methodClassName].bind(instance);
    }
    /**
     *
     */
    getHandler() {
        if (!this._rebuildHandler && this._handler) {
            return this._handler;
        }
        switch (this.handlerMetadata.type) {
            default:
            case "function":
                this._handler = this.handlerMetadata.target;
                break;
            case "middleware":
            case "controller":
                this._handler = this.buildHandler();
                break;
        }
        return this._handler;
    }
    /**
     *
     * @returns {Promise<TResult2|TResult1>}
     * @param request
     * @param response
     * @param next
     * @param err
     */
    invoke(request, response, next, err) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            next = this.buildNext(request, response, next);
            try {
                this.log(request, { event: "invoke.start" });
                const args = this.runFilters(request, response, next, err);
                const result = yield this.getHandler()(...args);
                if (!next.isCalled) {
                    if (this.handlerMetadata.type !== "function" && result !== undefined) {
                        request.storeData(result);
                    }
                    if (!this.handlerMetadata.nextFunction) {
                        next();
                    }
                }
            }
            catch (err) {
                next(err);
            }
        });
    }
    /**
     *
     * @param {Express.Request} request
     * @param o
     * @returns {string}
     */
    log(request, o = {}) {
        if (request.id && this.debug) {
            const target = this.handlerMetadata.target;
            const injectable = this.handlerMetadata.injectable;
            const methodName = this.handlerMetadata.methodClassName;
            request.log.debug(Object.assign({ type: this.handlerMetadata.type, target: (target ? core_1.nameOf(target) : target.name) || "anonymous", methodName,
                injectable, data: request && request.getStoredData ? request.getStoredData() : undefined }, o));
        }
    }
    /**
     *
     * @param {Express.Request} request
     * @param {Express.Response} response
     * @param {Express.NextFunction} next
     * @returns {any}
     */
    buildNext(request, response, next) {
        next.isCalled = false;
        return (error) => {
            next.isCalled = true;
            if (response.headersSent) {
                return;
            }
            /* istanbul ignore else */
            this.log(request, { event: "invoke.end", error });
            return next(error);
        };
    }
    /**
     *
     * @param request
     * @param response
     * @param next
     * @param err
     */
    runFilters(request, response, next, err) {
        return this.filters.map((filter) => {
            return filter({
                request,
                response,
                next,
                err
            });
        });
    }
}
exports.HandlerBuilder = HandlerBuilder;

//# sourceMappingURL=HandlerBuilder.js.map
