"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const ProviderType_1 = require("../../di/interfaces/ProviderType");
const ProviderRegistry_1 = require("../../di/registries/ProviderRegistry");
const constants_1 = require("../../filters/constants");
const ParamRegistry_1 = require("../../filters/registries/ParamRegistry");
const interfaces_1 = require("../interfaces");
class HandlerMetadata {
    constructor(_target, _methodClassName) {
        this._target = _target;
        this._methodClassName = _methodClassName;
        /**
         *
         */
        this._type = "function";
        /**
         *
         * @type {boolean}
         * @private
         */
        this._errorParam = false;
        /**
         *
         */
        this._injectable = false;
        this.resolve();
    }
    /**
     *
     */
    resolve() {
        this._useClass = this._target;
        let handler = this._target;
        let target = this._target;
        if (ProviderRegistry_1.ProviderRegistry.has(this._target)) {
            const provider = ProviderRegistry_1.ProviderRegistry.get(this._target);
            this._type = provider.type;
            if (provider.type === ProviderType_1.ProviderType.MIDDLEWARE) {
                this._type = "middleware";
                this._errorParam = core_1.Store.from(provider.provide).get("middlewareType") === interfaces_1.MiddlewareType.ERROR;
                this._methodClassName = "use";
                this._useClass = target = provider.useClass;
            }
        }
        if (this._methodClassName) {
            this._injectable = ParamRegistry_1.ParamRegistry.isInjectable(target, this._methodClassName);
            this._nextFunction = ParamRegistry_1.ParamRegistry.hasNextFunction(target, this._methodClassName);
            handler = target.prototype[this._methodClassName];
        }
        if (!this._injectable) {
            this._errorParam = handler.length === 4;
            this._nextFunction = handler.length >= 3;
        }
    }
    get type() {
        return this._type;
    }
    get errorParam() {
        return this._errorParam;
    }
    get injectable() {
        return this._injectable;
    }
    get nextFunction() {
        return this._nextFunction;
    }
    get methodClassName() {
        return this._methodClassName;
    }
    get target() {
        return this._target;
    }
    get services() {
        if (this.injectable) {
            return ParamRegistry_1.ParamRegistry.getParams(this._useClass, this.methodClassName);
        }
        const parameters = [{ service: constants_1.EXPRESS_REQUEST }, { service: constants_1.EXPRESS_RESPONSE }];
        if (this.errorParam) {
            parameters.unshift({ service: constants_1.EXPRESS_ERR });
        }
        if (this.nextFunction) {
            parameters.push({ service: constants_1.EXPRESS_NEXT_FN });
        }
        return parameters;
    }
}
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", String)
], HandlerMetadata.prototype, "_type", void 0);
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", Boolean)
], HandlerMetadata.prototype, "_errorParam", void 0);
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", Boolean)
], HandlerMetadata.prototype, "_injectable", void 0);
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", Boolean)
], HandlerMetadata.prototype, "_nextFunction", void 0);
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", Object)
], HandlerMetadata.prototype, "_useClass", void 0);
exports.HandlerMetadata = HandlerMetadata;

//# sourceMappingURL=HandlerMetadata.js.map
